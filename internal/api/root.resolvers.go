package api

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"github.com/exepirit/yggmap/internal/api/dto"
	"github.com/exepirit/yggmap/internal/data/entity"
	filter2 "github.com/exepirit/yggmap/internal/data/filter"
)

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, publicKey string) (*dto.YggdrasilNode, error) {
	node, err := r.NodesLoader.Load(ctx, publicKey)
	if err != nil {
		return nil, err
	}
	return mapYggdrasilNodeToDto(node), nil
}

// NodesList is the resolver for the nodesList field.
func (r *queryResolver) NodesList(ctx context.Context, query *dto.YggdrasilNodesQuery, previous *string, limit int) (*dto.YggdrasilNodesPage, error) {
	nodesFilter := filter2.Any[entity.YggdrasilNode]()
	if query != nil {
		nodesFilter = filter2.None[entity.YggdrasilNode]()

		if query.KeyOrAddress != nil {
			nodesFilter = filter2.Or(
				nodesFilter,
				filter2.NodeAddressContains(*query.KeyOrAddress),
				filter2.NodeKeyContainsStr(*query.KeyOrAddress),
			)
		}
	}

	page := &dto.YggdrasilNodesPage{
		Items: make([]*dto.YggdrasilNode, 0, limit),
	}
	err := r.NodesLoader.Provider.Iterate(ctx, previous, func(_ string, node entity.YggdrasilNode) bool {
		if !nodesFilter(node) {
			return true
		}

		page.Items = append(page.Items, mapYggdrasilNodeToDto(node))
		limit--
		return limit > 0
	})
	return page, err
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
